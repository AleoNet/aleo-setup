//! REST API endpoints exposed by the [Coordinator](`crate::Coordinator`).

use crate::{
    objects::Task,
    storage::{ContributionLocator, ContributionSignatureLocator},
    ContributionFileSignature,
};
use rocket::{
    error,
    get,
    http::{ContentType, Status},
    post,
    response::{Responder, Response},
    serde::{json::Json, Deserialize, Serialize},
    Request,
    Shutdown,
    State,
    tokio::{sync::RwLock, task},
};

use crate::{objects::LockedLocators, CoordinatorError, Participant};

use std::{collections::LinkedList, io::Cursor, net::SocketAddr, sync::Arc};
use thiserror::Error;

use tracing::debug;

type Coordinator = Arc<RwLock<crate::Coordinator>>;

/// Server errors. Also includes errors generated by the managed [Coordinator](`crate::Coordinator`).
#[derive(Error, Debug)]
pub enum ResponseError {
    #[error("Coordinator failed: {0}")]
    CoordinatorError(CoordinatorError),
    #[error("Thread panicked: {0}")]
    RuntimeError(String),
    #[error("Error while terminating the ceremony: {0}")]
    ShutdownError(String),
    #[error("Could not find contributor with public key {0}")]
    UnknownContributor(String),
    #[error("Could not find the provided Task {0} in coordinator state")]
    UnknownTask(Task),
    #[error("Error while verifying a contribution: {0}")]
    VerificationError(String),
}

impl<'r> Responder<'r, 'static> for ResponseError {
    fn respond_to(self, _request: &'r Request<'_>) -> rocket::response::Result<'static> {
        let response = format!("{}", self);
        Response::build()
            .status(Status::InternalServerError)
            .header(ContentType::JSON)
            .sized_body(response.len(), Cursor::new(response))
            .ok()
    }
}

type Result<T> = std::result::Result<T, ResponseError>;

/// The status of the contributor related to the current round.
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum ContributorStatus {
    Queue(u64, u64),
    Round,
    Finished,
    Other,
}

/// Request to get a [Chunk](`crate::objects::Chunk`).
#[derive(Deserialize, Serialize)]
pub struct GetChunkRequest {
    pubkey: String,
    locked_locators: LockedLocators,
}

impl GetChunkRequest {
    pub fn new(pubkey: String, locked_locators: LockedLocators) -> Self {
        GetChunkRequest {
            pubkey,
            locked_locators,
        }
    }
}

/// Contribution of a [Chunk](`crate::objects::Chunk`).
#[derive(Deserialize, Serialize)]
pub struct ContributeChunkRequest {
    pubkey: String,
    chunk_id: u64,
}

impl ContributeChunkRequest {
    pub fn new(pubkey: String, chunk_id: u64) -> Self {
        Self { pubkey, chunk_id }
    }
}

/// Request to post a [Chunk](`crate::objects::Chunk`).
#[derive(Clone, Deserialize, Serialize)]
pub struct PostChunkRequest {
    contribution_locator: ContributionLocator,
    contribution: Vec<u8>,
    contribution_file_signature_locator: ContributionSignatureLocator,
    contribution_file_signature: ContributionFileSignature,
}

impl PostChunkRequest {
    pub fn new(
        contribution_locator: ContributionLocator,
        contribution: Vec<u8>,
        contribution_file_signature_locator: ContributionSignatureLocator,
        contribution_file_signature: ContributionFileSignature,
    ) -> Self {
        Self {
            contribution_locator,
            contribution,
            contribution_file_signature_locator,
            contribution_file_signature,
        }
    }
}

//
// -- REST API ENDPOINTS --
//

/// Add the incoming contributor to the queue of contributors.
#[post("/contributor/join_queue", format = "json", data = "<contributor_pubkey>")]
pub async fn join_queue(
    coordinator: &State<Coordinator>,
    contributor_pubkey: Json<String>,
    contributor_ip: SocketAddr,
) -> Result<()> {
    let pubkey = contributor_pubkey.into_inner();
    let contributor = Participant::new_contributor(pubkey.as_str());

    let mut write_lock = (*coordinator).clone().write_owned().await;

    match task::spawn_blocking(move || write_lock.add_to_queue(contributor, Some(contributor_ip.ip()), 10))
        .await
        .map_err(|e| ResponseError::RuntimeError(format!("{}", e)))?
    {
        Ok(()) => Ok(()),
        Err(e) => Err(ResponseError::CoordinatorError(e)),
    }
}

/// Lock a [Chunk](`crate::objects::Chunk`) in the ceremony. This should be the first function called when attempting to contribute to a chunk. Once the chunk is locked, it is ready to be downloaded.
#[post("/contributor/lock_chunk", format = "json", data = "<contributor_pubkey>")]
pub async fn lock_chunk(
    coordinator: &State<Coordinator>,
    contributor_pubkey: Json<String>,
) -> Result<Json<LockedLocators>> {
    let pubkey = contributor_pubkey.into_inner();
    let contributor = Participant::new_contributor(pubkey.as_str());

    let mut write_lock = (*coordinator).clone().write_owned().await;

    match task::spawn_blocking(move || write_lock.try_lock(&contributor))
        .await
        .map_err(|e| ResponseError::RuntimeError(format!("{}", e)))?
    {
        Ok((_, locked_locators)) => Ok(Json(locked_locators)),
        Err(e) => Err(ResponseError::CoordinatorError(e)),
    }
}

/// Download a chunk from the [Coordinator](`crate::Coordinator`), which should be contributed to upon receipt.
#[get("/download/chunk", format = "json", data = "<get_chunk_request>")]
pub async fn get_chunk(
    coordinator: &State<Coordinator>,
    get_chunk_request: Json<GetChunkRequest>,
) -> Result<Json<Task>> {
    let request = get_chunk_request.into_inner();
    let contributor = Participant::new_contributor(request.pubkey.as_ref());

    let next_contribution = request.locked_locators.next_contribution();

    // Build and check next Task
    let task = Task::new(next_contribution.chunk_id(), next_contribution.contribution_id());

    let read_lock = (*coordinator).clone().read_owned().await;

    match task::spawn_blocking(move || read_lock.state().current_participant_info(&contributor).cloned())
        .await
        .map_err(|e| ResponseError::RuntimeError(format!("{}", e)))?
    {
        Some(info) => {
            if !info.pending_tasks().contains(&task) {
                return Err(ResponseError::UnknownTask(task));
            }
            Ok(Json(task))
        }
        None => Err(ResponseError::UnknownContributor(request.pubkey)),
    }
}

/// Download the challenge from the [Coordinator](`crate::Coordinator`) accordingly to the [`LockedLocators`] received from the Contributor.
#[get("/contributor/challenge", format = "json", data = "<locked_locators>")]
pub async fn get_challenge(
    coordinator: &State<Coordinator>,
    locked_locators: Json<LockedLocators>,
) -> Result<Json<Vec<u8>>> {
    let request = locked_locators.into_inner();

    let challenge_locator = request.current_contribution();
    let round_height = challenge_locator.round_height();
    let chunk_id = challenge_locator.chunk_id();

    debug!(
        "rest::get_challenge - round_height {}, chunk_id {}, contribution_id 0, is_verified true",
        round_height, chunk_id
    );

    let mut write_lock = (*coordinator).clone().write_owned().await;

    // Since we don't chunk the parameters, we have one chunk and one allowed contributor per round. Thus the challenge will always be located at round_{i}/chunk_0/contribution_0.verified
    // For example, the 1st challenge (after the initialization) is located at round_1/chunk_0/contribution_0.verified
    match task::spawn_blocking(move || write_lock.get_challenge(round_height, chunk_id, 0, true))
        .await
        .map_err(|e| ResponseError::RuntimeError(format!("{}", e)))?
    {
        Ok(challenge_hash) => Ok(Json(challenge_hash)),
        Err(e) => Err(ResponseError::CoordinatorError(e)),
    }
}

/// Upload a [Chunk](`crate::objects::Chunk`) contribution to the [Coordinator](`crate::Coordinator`). Write the contribution bytes to
/// disk at the provided [Locator](`crate::storage::Locator`). Also writes the corresponding [`ContributionFileSignature`]
#[post("/upload/chunk", format = "json", data = "<post_chunk_request>")]
pub async fn post_contribution_chunk(
    coordinator: &State<Coordinator>,
    post_chunk_request: Json<PostChunkRequest>,
) -> Result<()> {
    let request = post_chunk_request.into_inner();
    let request_clone = request.clone();
    let mut write_lock = (*coordinator).clone().write_owned().await;

    if let Err(e) =
        task::spawn_blocking(move || write_lock.write_contribution(request.contribution_locator, request.contribution))
            .await
            .map_err(|e| ResponseError::RuntimeError(format!("{}", e)))?
    {
        return Err(ResponseError::CoordinatorError(e));
    }

    write_lock = (*coordinator).clone().write_owned().await;
    match task::spawn_blocking(move || {
        write_lock.write_contribution_file_signature(
            request_clone.contribution_file_signature_locator,
            request_clone.contribution_file_signature,
        )
    })
    .await
    .map_err(|e| ResponseError::RuntimeError(format!("{}", e)))?
    {
        Ok(()) => Ok(()),
        Err(e) => Err(ResponseError::CoordinatorError(e)),
    }
}

/// Notify the [Coordinator](`crate::Coordinator`) of a finished and uploaded [Contribution](`crate::objects::Contribution`). This will unlock the given [Chunk](`crate::objects::Chunk`) and allow the contributor to take on a new task.
#[post(
    "/contributor/contribute_chunk",
    format = "json",
    data = "<contribute_chunk_request>"
)]
pub async fn contribute_chunk(
    coordinator: &State<Coordinator>,
    contribute_chunk_request: Json<ContributeChunkRequest>,
) -> Result<Json<ContributionLocator>> {
    let request = contribute_chunk_request.into_inner();
    let contributor = Participant::new_contributor(request.pubkey.as_ref());

    let mut write_lock = (*coordinator).clone().write_owned().await;

    match task::spawn_blocking(move || write_lock.try_contribute(&contributor, request.chunk_id))
        .await
        .map_err(|e| ResponseError::RuntimeError(format!("{}", e)))?
    {
        Ok(contribution_locator) => Ok(Json(contribution_locator)),
        Err(e) => Err(ResponseError::CoordinatorError(e)),
    }
}

/// Update the [Coordinator](`crate::Coordinator`) state.
#[cfg(debug_assertions)]
#[get("/update")]
pub async fn update_coordinator(coordinator: &State<Coordinator>) -> Result<()> {
    let mut write_lock = (*coordinator).clone().write_owned().await;

    match task::spawn_blocking(move || write_lock.update())
        .await
        .map_err(|e| ResponseError::RuntimeError(format!("{}", e)))?
    {
        Ok(()) => Ok(()),
        Err(e) => Err(ResponseError::CoordinatorError(e)),
    }
}

/// Lets the [Coordinator](`crate::Coordinator`) know that the participant is still alive and participating (or waiting to participate) in the ceremony.
#[post("/contributor/heartbeat", format = "json", data = "<contributor_pubkey>")]
pub async fn heartbeat(coordinator: &State<Coordinator>, contributor_pubkey: Json<String>) -> Result<()> {
    let pubkey = contributor_pubkey.into_inner();
    let contributor = Participant::new_contributor(pubkey.as_str());

    let mut write_lock = (*coordinator).clone().write_owned().await;

    match task::spawn_blocking(move || write_lock.heartbeat(&contributor))
        .await
        .map_err(|e| ResponseError::RuntimeError(format!("{}", e)))?
    {
        Ok(()) => Ok(()),
        Err(e) => Err(ResponseError::CoordinatorError(e)),
    }
}

/// Get the pending tasks of contributor.
#[get("/contributor/get_tasks_left", format = "json", data = "<contributor_pubkey>")]
pub async fn get_tasks_left(
    coordinator: &State<Coordinator>,
    contributor_pubkey: Json<String>,
) -> Result<Json<LinkedList<Task>>> {
    let pubkey = contributor_pubkey.into_inner();
    let contributor = Participant::new_contributor(pubkey.as_str());

    let read_lock = (*coordinator).clone().read_owned().await;

    match task::spawn_blocking(move || read_lock.state().current_participant_info(&contributor).cloned())
        .await
        .map_err(|e| ResponseError::RuntimeError(format!("{}", e)))?
    {
        Some(info) => Ok(Json(info.pending_tasks().to_owned())),
        None => Err(ResponseError::UnknownContributor(pubkey)),
    }
}

/// Stop the [Coordinator](`crate::Coordinator`) and shuts the server down. This endpoint should be accessible only by the coordinator itself.
#[get("/stop")]
pub async fn stop_coordinator(coordinator: &State<Coordinator>, shutdown: Shutdown) -> Result<()> {
    let mut write_lock = (*coordinator).clone().write_owned().await;

    let result = task::spawn_blocking(move || write_lock.shutdown())
        .await
        .map_err(|e| ResponseError::RuntimeError(format!("{}", e)))?;

    if let Err(e) = result {
        return Err(ResponseError::ShutdownError(format!("{}", e)));
    };

    // Shut Rocket server down
    shutdown.notify();

    Ok(())
}

// FIXME: speed tests

/// Verify all the pending contributions. This endpoint should be accessible only by the coordinator itself.
#[get("/verify")]
pub async fn verify_chunks(coordinator: &State<Coordinator>) -> Result<()> {
    // Get all the pending verifications, loop on each one of them and perform verification
    let pending_verifications = coordinator.read().await.get_pending_verifications().to_owned();

    for (task, _) in pending_verifications {
        let mut write_lock = (*coordinator).clone().write_owned().await;
        // NOTE: we are going to rely on the single default verifier built in the coordinator itself,
        //  no external verifiers
        if let Err(e) = task::spawn_blocking(move || write_lock.default_verify(&task))
            .await
            .map_err(|e| ResponseError::RuntimeError(format!("{}", e)))?
        {
            return Err(ResponseError::VerificationError(format!("{}", e)));
        }
    }

    Ok(())
}

/// Get the queue status of the contributor.
#[get("/contributor/queue_status", format = "json", data = "<contributor_pubkey>")]
pub async fn get_contributor_queue_status(
    coordinator: &State<Coordinator>,
    contributor_pubkey: Json<String>,
) -> Result<Json<ContributorStatus>> {
    let pubkey = contributor_pubkey.into_inner();
    let contributor = Participant::new_contributor(pubkey.as_str());

    // Check that the contributor is authorized to lock a chunk in the current round.
    if coordinator.read().await.is_current_contributor(&contributor) {
        return Ok(Json(ContributorStatus::Round));
    }

    if coordinator.read().await.is_queue_contributor(&contributor) {
        let queue_size = coordinator.read().await.state().number_of_queue_contributors() as u64;
        let queue_position = match coordinator.read().await.state().queue_contributor_info(&contributor) {
            Some((_, Some(round), _, _)) => round - coordinator.read().await.state().current_round_height(),
            Some((_, None, _, _)) => queue_size,
            None => return Ok(Json(ContributorStatus::Other)),
        };

        return Ok(Json(ContributorStatus::Queue(queue_position, queue_size)));
    }

    if coordinator.read().await.is_finished_contributor(&contributor) {
        return Ok(Json(ContributorStatus::Finished));
    }

    // Not in the queue, not finished, nor in the current round
    Ok(Json(ContributorStatus::Other))
}
